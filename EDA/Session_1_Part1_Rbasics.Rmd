---
title: "Intro to R and Data Visualization with ggplot2: Session 1"
subtitle: "UCI Data Science Initiative"
date: "22 June 2020"
author: "Arnold Seong"
output:
  xaringan::moon_reader:
    lib_dir: libs
    css:
      - default
      - default-fonts
      - "https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css"
      - xaringan-themer.css
    nature:
      highlightStyle: github
      highlightSpans: true
      highlightLines: true
      countIncrementalSlides: false
---

```{r setup, include=FALSE, message=F, echo=F, warning=F}
library(xaringanthemer)
style_mono_accent(base_color = "#3C989E")

knitr::opts_chunk$set(cache=TRUE, warning=FALSE, message=FALSE, echo=TRUE, warning=FALSE, error=TRUE)

#set scientific notation digit threshold
options(scipen=10)

#load libraries
library(dplyr)
library(ggplot2)
library(RColorBrewer)
```

layout: true

<style>
pre {
    display: block;
    font-family: monospace;
    white-space: pre;
    margin: 1em 0px;
    margin-top: 0.5em;
    margin-right: 0px;
    margin-bottom: 0em;
    margin-left: 0px;
}
.remark-inline-code {
  background: #F5F5F5;
}
</style>




---
class: animated, fadeIn

## Workshop info
+ We will be recording today's sessions for potential future use
    + You may not want to activate video
    + Please set your zoom to mute your audio until you would like to speak
    + You can change your icon name by mousing over, clicking on the 3 dots
    
+ Please ask questions during lectures & throughout the day!
    + Use chat
    + Raise hand (`Alt+Y`)
    + Unmute yourself temporarily (hold `Spacebar`).






---
## Warning!
We will be using the New York Times' COVID-19 dataset throughout this workshop (still being updated at the time these slides were made).

--

Some of you may be conducting research on COVID-19.  

--

+ Doing EDA on a dataset that you are also planning to use for inference / hypothesis tests *is* good practice, but can pose [**serious problems**](https://en.wikipedia.org/wiki/Data_dredging) if done improperly.

--

  + EDA affecting your hypotheses = invalid statistical anlysis

--

+ However:
    1. the EDA / visualizations we will do here are either quite general or already widely available / disseminated 
        (i.e. at the [**New York Times**](https://www.nytimes.com/interactive/2020/us/coronavirus-us-cases.html)
        or [**JHU**](https://coronavirus.jhu.edu/map.html));
    1. we will not conduct any statistical tests;
    1. the data we use is fairly limited (date, county, and number cases/deaths).





---
## Workshop Goals

Primary goal: Using R and ggplot2 to accomplish common tasks related to data exploration and visualization
+ Coding in R to explore data and manipulate data into useful forms
+ ggplot2 basics + some customization 
+ Share some practical/workflow tips

Caveats:    
+ This workshop assumes a little familiarity with R
+ Not comprehensive
+ Tidy-ish only
+ This workshop is not about statistics, but basic statistical knowledge is assumed


 

---
class: inverse
## Session 1 Topics

1. R and Rstudio basics (credit to Chris Galbraith, Emily Smith)
  + R fundamentals: data types, data structures, reading data, subsetting
  + Using R: functions, loops, writing data

2. Basic data exploration
  + Getting a sense of your data: summaries, tables
  + Making your data useful: transformations
  + plotting with base R





---
class: inverse, animated, fadeIn
## Session 1 Topics

1. R and Rstudio basics (credit to Chris Galbraith, Emily Smith)
  + R fundamentals: data types, data structures, reading data, subsetting
  + **Using R: functions, loops, writing data**

2. **Basic data exploration**
  + **Getting a sense of your data: summaries, tables**
  + **Making your data useful: transformations**
  + **plotting with base R**






---
## What is R?
+ R is a free software environment for statistical computing and graphics
    + See http://www.r-project.org/ for more info 
+ R compiles and runs on a wide variety of UNIX platforms, Windows and Mac OS
+ R is open-source and free
+ R is fundamentally a command-driven system
+ R is an object-oriented programming language 
    + Everything in R is an object (data, functions, etc.)
+ R is highly extendable
    + You can write your own custom functions
    + There are over 11,000 free add-on packages





---
## RStudio
+ RStudio is a free and open source integrated development environment (IDE) for R.
+ Visit http://rstudio.org/ for more info
+ Please note that you must have R already installed before installing R Studio!






---
## RStudio Tips/Features
+ In the script pane, use `Ctrl + Enter` or `Alt + Enter` to execute current line(s) or selection
    + in RGui, `Ctrl + R` does the same thing
    
+ In the console, Up/Down arrow keys scroll through last executed lines of code

+ Customizable interface

+ Code completion
    + basic error detection
    + can include own code snippets

+ Tearout panes (but save-as and set working directory can be finicky)

+ Multicursor!  (`Alt + Ctrl + Arrow keys`)





---
## Fundamentals of R
+ When you execute commands / lines of code
    + R tries to interpret what you've asked it to do (evaluation)
    + If it understands what you've written, it does it (execution)
    + If it doesn't, it will likely give you an error or a warning

+ Some commands trigger R to print to the screen, others don't

+ If you type an incomplete command, R will usually respond by changing the command prompt to the '+' character
    + Hit ESC on a MAC to cancel
    + Type `Ctrl + C` on Windows and Linux to cancel





---
## Functions in R

More on functions later, but for now: 

1. R has many built-in functions

2. Each function has a name followed by (), e.g., `mean()`

3. Arguments of a function are put within the parentheses

4. Help files are available for each function by typing ? followed by the function name, e.g., `?mean`

5. We will be using functions throughout the workshop




---
## Data Types in R

+ R has 5 main atomic data types:

  + Numeric:   &nbsp; `5`,    &nbsp; `1.3`, &nbsp; `0.004294`
  
  + Character: &nbsp; `"a"`,  &nbsp; `"abracadabra"`, &nbsp; `"two"`
  
  + Logical:   &nbsp; `TRUE`, &nbsp; `FALSE`
  
  + Integer:   &nbsp; `2L`
  
  + Complex:   &nbsp; `1+4i`




---
## Data Structures in R

1. One-dimensional:
    + Vectors
    
2. Multi-dimensional:
    + Matrices/Arrays
    + Lists
    + Data frames


--

Everything in R is an object:

+ Objects can have attributes and methods associated with object types
    + attributes include names, dimension, length
    + methods = specific ways a function handles an object type




---
## Vectors in R
+ Most basic object in R
+ One-dimensional
+ Length = # elements in vector
+ Each element is a single value (e.g. numeric or string value)
    + In general, vectors can only hold ONE data type
  
```{r Vectors}
num_vec <- c(2,3,4)  # <- is the assigning operator
num_vec
```
--
```{r}
length(num_vec)  # gives the number of elements in the vector
```
--
```{r}
x <- 2
is.vector(x)  # single numbers are stored as vectors of length 1
```






---
## Examples of Character and Logical Vectors

```{r Character_and_Logical_Vector_Examples}
log_vec <- c(TRUE, FALSE, FALSE, T, F)
log_vec
```
--
```{r}
char_vec <- c("red", "green", "blue")
char_vec
```
--
```{r}
log_vec2 <- char_vec=="red"
log_vec2
```
--
```{r}
char_vec2 <- c("green", "red", "blue")
char_vec2 == char_vec
```






---
## Logical Operators

In the previous slide, you saw two code chunks using `==`

--

(Here is one of them again)
```{r, eval=F}
log_vec2 <- char_vec`==`"red"
log_vec2
```

--


The double-equals sign `==` is a logical operator.

  - A single equals sign `=` works (mostly) the same as `<-` in R.  
  
--

- `log_vec2 <- char_vec=="red"` asks R to evaluate whether the value stored in the variable `char_vec` is exactly equal to the string `"red"`.  

--

- As you saw, R tests each element in `char_vec` and returns `TRUE` or `FALSE`





---
## Logical Operators cont'd

Other logical operators: 

--

- numerical comparisons: &nbsp; &nbsp; `>`, &nbsp; &nbsp; `>=`, &nbsp; &nbsp; `<`, &nbsp; &nbsp; `<=`

--

- equals, not equals: &nbsp; &nbsp; `==`, &nbsp; &nbsp; `!=`

--

- not, and, or (and/or), strictly or: &nbsp; &nbsp; `!`, &nbsp; &nbsp; `&`, &nbsp; &nbsp; `|` (pipe), &nbsp; &nbsp; `xor(x,y)`

--

#### &nbsp; 

Each of these will perform element-wise operations on vectors:

```{r}
x <- 1:10
y <- 10:1
x > y
```



---
class: animated, fadeIn
## Logical Operators cont'd

Other logical operators: 

- numerical comparisons: &nbsp; &nbsp; `>`, &nbsp; &nbsp; `>=`, &nbsp; &nbsp; `<`, &nbsp; &nbsp; `<=`

- equals, not equals: &nbsp; &nbsp; `==`, &nbsp; &nbsp; `!=`

- not, and, or (and/or), strictly or: &nbsp; &nbsp; `!`, &nbsp; &nbsp; `&`, &nbsp; &nbsp; `|` (pipe), &nbsp; &nbsp; `xor(x,y)`

--

#### &nbsp; 

The operators in the last bullet`!`, `&`, `|`, `xor(x,y)` take logical vectors as input:

```{r}
log_vec
!log_vec
```






---
## Data Type Coercion
- In general, vectors CANNOT have mixed types of data

- If you create a vector with more than one type of data, R will automatically coerce it to a single type

```{r data_type_coercion1}
numchar_vec <- c(3.14, pi, "pi")
numchar_vec                 
```

--

- Explicitly coerce objects from one type to another using `as()`
  - Be careful about warnings; always check it became what you wanted!

```{r data_type_coercion2}
num_vec <- 1:10
num_vec
```

--

```{r}
was_num_vec <- as(num_vec, "character")
was_num_vec
```


---
## Data Type Coercion
- In general, vectors CANNOT have mixed types of data

- If you create a vector with more than one type of data, R will automatically coerce it to a single type

```{r data_type_coercion1.1}
numchar_vec <- c(3.14, pi, "pi")
numchar_vec                 
```


- Explicitly coerce objects from one type to another using `as()`
  - Be careful about warnings; always check it became what you wanted!

--

```{r, error=TRUE}
num_vec + 1
was_num_vec + 1
```





---
## Factors
- A **factor** is a vector object used to specify a discrete classification (categorical values or "levels")

--

- Factors are stored as numbers + a table of levels.  Thus, they
  - use less memory than character vectors
  - comparisons may be faster than character vectors
  - can be given clearer labels than numeric indicators
  - factors can be purposefully given an order

--

- Factors are associated with specific methods (i.e. functions treat them in specific ways)





---
## Factors: example
- Consider a vector `sex` representing males as 0 and females as 1: 
    
```{r factors1}
sex <- rep(c(0,1), times = 4)
sex
```

--
- **Will anyone else know what this means?!**

--

- Instead, let's recode this as a factor with clear labels:

```{r factors2}
sex2 <- factor(sex, 
               levels=c(0,1),  # original values
               labels=c("Male", "Female")) # new values
sex2
```





---
## Factors: re-levelling

+ Nice for inconsistent data

```{r}
sex <- factor(c("Male", "Female", "M", "F", "Dude", "F", "Male", "Dudette"))
sex
```

--

```{r}
sex <- factor(sex, 
              levels=c("Dude", "Dudette", "F", "Female", "M", "Male"),
              labels=c("Male", "Female", "Female", "Female", "Male", "Male"))
sex
```








---
## Factors: level order 1
- By default levels are ordered alphabetically:

```{r factors_level_order1}
sizes <- factor(c("small", "med", "large"))
sizes      # levels ordered alphabetically
```

--
#### &nbsp;
- Levels can be specified explicitly to change order

```{r factors_level_order2}
sizes_ord <- factor(sizes, levels=c("small", "med", "large"))
sizes_ord # same values, but levels are in the specified order
```

???
<!-- comments -->
spending time on this b/c factor order changes how ggplot2 displays legends






---
class: animated, fadeIn
## Factors: level order 2

- As mentioned, levels have assigned numbers:
```{r factors_level_order1rep}
sizes <- factor(c("small", "med", "large"))
sizes
```

--
#### &nbsp;
- Level order matters to assigned numbers:

--

```{r}
as.numeric(sizes)  # levels ordered alphabetically (default)
```

--

```{r}
as.numeric(sizes_ord)  # levels ordered by small to large sizes
```






---
class: animated, fadeIn
## Factors: level order 2

- As mentioned, levels have assigned numbers:
```{r factors_level_order1rep2}
sizes <- factor(c("small", "med", "large"))
sizes
```

--
#### &nbsp;
- But level number doesn't change the values in the vector

```{r}
as.numeric(sizes)==as.numeric(sizes_ord)
sizes==sizes_ord
```







---
## Matrices
A **matrix** is a special case of a vector (matrices have 2 dimensions)
  + Like vectors, all elements of a matrix should be of the same data type

```{r Matrices}
myMat <- matrix(NA, nrow = 2, ncol = 4)
myMat
```

--
In addition to the `length()` function, we can use `dim()` with matrices:

```{r}
length(myMat)  # gives total # of elements (nrow times ncol)
dim(myMat)  # gives a length 2 vector (nrow, ncol)

```






---
## Creating Matrices: using a vector
We can fill a matrix using a vector (or function returning a vector)

```{r fill_Matrix}
evens <- seq(2, 16, 2)
evens
```


#### &nbsp;
--

By default, matrices are filled by column
```{r}
myMat <- matrix(evens, nrow = 2, ncol = 4)
myMat 

```






---
class: animated, fadeIn
## Creating Matrices: using a vector
We can fill a matrix using a vector (or function returning a vector)

```{r fill_Matrix2}
evens <- seq(2, 16, 2)
evens
```


#### &nbsp;
But we can also fill the matrix by row 



```{r}
myMat <- matrix(evens, nrow = 2, ncol = 4, byrow=TRUE)
myMat
```




---
## Creating Matrices: `cbind()`
`rbind()` and `cbind()` (row bind and column bind) combine vectors into a matrix 

```{r echo=TRUE}
vec1 <- 1:4
vec2 <- 5:8
vec3 <- 9:12
```

--
#### &nbsp;

`cbind()` example:

```{r}
colMat <- cbind(vec1, vec2, vec3)
colMat
```

--
Notice the **columns** are named.






---
class: animated, fadeIn
## Creating Matrices: `rbind()`

`rbind()` and `cbind()` (row bind and column bind) combine vectors into a matrix 

```{r echo=TRUE}
vec1 <- 1:4
vec2 <- 5:8
vec3 <- 9:12
```

--
#### &nbsp;

`rbind()` example:

```{r echo=TRUE}
rowMat <- rbind(vec1, vec2, vec3)
rowMat
```

--
Notice the **rows** are named.

--
You can extract or change the column and row names using `colnames()` and `rownames()` (or `dimnames()`)





---
## Arrays:

Matrices are 2-dimensional **arrays**.

+ Arrays can have an arbitrary number of dimensions.

--

Here is one slice of a 3-dimensional array:

```{r}
myArr <- array(1:5, dim=c(3, 4, 5))  # something fishy here?
myArr[, , 1]
```

--
(Notice that the vector `1:5` simply gets repeated in order to populate the entire array.)

--

Providing names for the dimensions of an array -- use `dimnames()` -- will help you stay sane.  






---
## Lists
Unlike vectors, matrices, or arrays, **lists** can contain multiple data types and data structures, and each element in a list can be of different length/dimension.

```{r}
myList <- list("sex"=sex,       # a vector
               "rowMat"=rowMat) # a matrix
length(myList)
myList
```








---
## Special Values
There are some special values in R:

  + `Inf`: infinity
  + `NaN`: "Not a number"
  
```{r echo=TRUE}
a <- Inf
b <- 0
rslt <- c(b/a, a/a, 1/b)
rslt
```





---
## Missing Values
+ There are two kinds of missing values in R:
    + `NaN`: stands for "Not a Number" and is a missing value produced by numerical computation
    + `NA`: stands for "Not Available" and is used when a value is missing
    
```{r echo=TRUE}
a <- c(1,2)
a[3]

b <- 0/0
b
```





---
## Missing Values, contd.
+ `is.na()` and `is.nan()` are functions that indicate which value(s) of an object are missing

--

Careful:  
+ `NaN` is considered to be `NA` 

```{r, echo=TRUE}
na_vec <- c(NA, NaN)
is.na(na_vec)
```

--

+ but the reverse is NOT true

```{r, echo=TRUE}
is.nan(na_vec)
```





---
## Data Frames
Data frames are uniquely useful objects for data analysis!
+ A data frame looks very similar to a matrix, but...

--

+ **different columns** in a data frame can house **different data types**

--

```{r}
female <- rep(c(0,1), times = 4)
height <- sample(62:70, length(female), replace=TRUE)
df <- data.frame(female, sex, height)
df
```

--

Data frames combine features of lists and matrices





---
## Reading Data into R

Main functions for reading data into R:

--

1. `read.table()`, `read.csv()`: to read tabular data 
    + Type `?read.table` in your R console to see the important arguments in the function
    + `read.csv()` for comma separated value files 
        + Equivalent to `read.table()` with arguments `sep = ","` and `header = TRUE`

--

2. `readLines()`: to read lines of a text file

--

3. `source()`, `dget()`: to read R code

--

4. `load()`: to read saved workspaces and R data files (`.Rda`, `.Rdata`)





---
## Reading Data into R, contd.
Sometimes the hardest part of reading data into R is pointing R to the data.  

--

+ If your data is stored locally, I recommend that you  
  + Make a folder (e.g. `myproj`) to keep all files for your data analysis project
  + Save your main script in `myproj`
  + Save your data in another folder `myproj/data`  


--

+ Then, in R:  
    + Use `setwd("path_to_myproj/myproj")` to set your working directory to that folder
    + Alternatively, use RStudio's top banner menu: 
        + Session $\rightarrow$ Set Working Directory $\rightarrow$ Source File Location
    + Then use `read.csv("data/data_file.csv")`

--

We will use data hosted online here (to get the most up-to-date data), but I still recommend keeping your data analysis project files together.





---
## Optional workshop item: R Projects

 
It's useful to know how to navigate file systems in R 

--

... but it can be a hassle.  

--

Once you feel a bit more comfortable in R and RStudio, try starting your data analysis with a new **R project**:  

+ in RStudio's banner menu, go to **File $\rightarrow$ New Project**

+ follow the options from there (self-explanatory)





---
## Optional workshop item: R Projects cont'd

We won't go into detail on R Projects here, but it has many advantages:

+ working directory is by default set to the home folder of the project

  + send the whole project to collaborators easily (filepaths won't break!)

+ saves its own, separate R workspace (easy to pick right back up)

+ integration with Git and Github


--

+ *quick tips:* 
  + all files for the project should be in the home folder or subfolders
  + pick up where you left off on your project by 
     1. clicking on the **.Rproj** file in your local home folder
     1. using the project dropdown in the upper right of the RStudio banner.





---
## NYTimes Covid-19 data
Today we will be using the New York Times' Covid-19 dataset at [https://github.com/nytimes/covid-19-data](https://github.com/nytimes/covid-19-data), and augmenting it with a few other sources of information as we continue through our data exploration.  

--

The original dataset contains the following variables:

+ `date`:   &nbsp;       date of observation
+ `county`: &nbsp;       county
+ `state`:  &nbsp;       state
+ `fips`:   &nbsp;       Federal Information Processing Standards codes (unique identifiers for counties)
+ `cases`:  &nbsp;       cumulative cases in county on given date
+ `deaths`: &nbsp;       cumulative deaths

--

Let's load the data.

```{r load_C19_data}
ct <- read.csv("https://raw.githubusercontent.com/nytimes/covid-19-data/master/us-counties.csv")
ct$date <- as.Date(ct$date)
ct <- ct %>% filter(date < "2020-06-23")
```





---
## NYTimes Covid-19 data: head

Now that we have a data frame loaded, let's take a quick look at the 'head' of the data.
+ The `head()` function by default, displays the first 6 rows.

--

```{r}
head(ct)
```

--
Let's look at this for a moment to see what we see...





---
## NYTimes Covid-19 data: tail
There's also a `tail()` function.

--

```{r}
tail(ct, 5)  # specify just the last 5 rows
```

--

After looking at the head and tail, what are some things you can tell about the dataset?

--

- number of rows, date range (possible), ordering of dataset, formatting of variables

--
- each row = observation of 1 county on 1 day (i.e. "long" format)

--
- does not seem like every county is present every day

--
- appears to be mostly low numbers in `cases` and mostly 0's in `deaths`




---
class: animated, fadeIn
## NYTimes Covid-19 data: tail
There's also a `tail()` function.

```{r}
tail(ct, 5)  # specify just the last 5 rows
```

After looking at the head and tail, what are some questions you have about the dataset?  What do you want to confirm about the dataset?

--

- confirm date range, every county not recorded every day

--
- data from all counties? All states? US territories included?

--

Before we can do this, we need to discuss **subsetting**






---
## Subsetting

Two main subsetting operators:
- `[ ]` single brackets return an object of the same class as the original object

- `$` used primarily for selecting columns from data frames

  - We use `$` when selecting an attribute by name

#### &nbsp;

--

- `[ ]` allows us to select more than one element 

- `$` allows us to select only one

#### &nbsp;

--

(There's also `[[ ]]`, which extracts elements from lists without retaining list structure)






---
## Subsetting Vectors

```{r, eval=FALSE}
vec <- 1:10    # integers from 1 to 10
vec[3]         # predict output
```
--
```{r, echo=FALSE}
vec <- 1:10
vec[3] 
```
--
Remember that single brackets allow us to select more than one element of an object:
```{r, eval=FALSE}
vec[1:3]        # predict output
```
--
```{r, echo=FALSE}
vec[1:3]
```
--

Notice that to select multiple items, the indices must be in a vector.  (`1:3` in the previous lines constructs a vector)

```{r, eval=FALSE}
vec[c(2,4,6)]   # predict output 
```
--
```{r, echo=FALSE}
vec[c(2,4,6)] 
```







---
## Subsetting Data Frames:
We also use the single square brackets to subset data frames (2 dimensions!)
--

- In the square brackets, the first position refers to the row(s) and the second position refers to the column(s)
- i.e. `df[row_num, col_num]`


--

```{r}
ct[1:2, ]  # get the first 2 rows
```

--

```{r}
ct[1, 2]   # get the element in the first row, second column
```





---
## Subsetting Data Frames, contd.
- We use `$` when selecting an attribute by name
  - This is commonly used to subset a column of a data frame
- Can combine `$` with `[ ]`. 

--

The following are all equivalent (`fips` is the 4th column):
--
```{r}
head(ct$fips)  # select the first 6 values of the second column
```
--
```{r}
ct$fips[1:6]
```
--
```{r}
ct[1:6, 4]
```






---
## Subsetting using Index Vectors
+ Another way to select more than one element from an object (vector, matrix, list, dataframe) is by using **index vectors**

+ We will cover three types of index vectors: 

--

  1. Logical index vector
  
--

  1. Vector of positive integers

--

  1. Vector of character strings

--

+ An index vector can be longer than the vector being subsetted if repeating elements

```{r, eval=F}
vac <- 1:10
vec[c(1, 1, 1)]  # predict output
```
--
```{r, echo=F}
vec[c(1, 1, 1)]
```





---
## 1. Logical Index Vector
+ A vector of `TRUE`/`FALSE` values of same length as the vector to be subsetted.

--
```{r}
geq10k <- ct$cases > 10000  # T/F returned 
length(geq10k)
length(ct$cases)
```
--

+ Values corresponding to TRUE in the index vector are selected

--

```{r}
tail(geq10k)
tail(ct$cases)
```








---
## 1. Logical Index Vector, cont'd
+ A vector of `TRUE`/`FALSE` values of same length as the vector to be subsetted.

+ Values corresponding to TRUE in the index vector are selected

+ T/F can also be treated as 1/0
--

```{r}
sum(geq10k) # Treats TRUE as 1 and FALSE as 0 
```


So we have `r sum(geq10k)` **observations** of cumulative case counts greater than 10,000

--

Since `r sum(geq10k)` entries may be too many to look at individually, we should figure out what we really want to know.






---
## 1. Logical Index Vector, cont'd

Remember that each observation is a single county *on a single day*.

We might be interested in how many counties have case counts above 10000.  

--

We'll do this using the `unique()` function, which extracts only the first instance of a repeated value.

--

```{r}
length(unique(ct$county[geq10k]))
```

--

If we want to see the names of all the counties, we can (but this won't fit on a single slide):

--

```{r}
unique(ct$county[geq10k])
```










---
## 2. Index Vector of Positive Integers
+ A vector of positive integers identifying the position of the elements you want to subset
+ We can use the function `which()` along with logical conditions to create this index vector
  + combine logical conditions using `&` for "and", or `|` for "or"

```{r}
CA_geq5k <- which(ct$state=="California" 
                  & ct$date=="2020-06-01"
                  & ct$cases > 5000)
```

--

```{r}
ct[CA_geq5k, ]
```





---
## 3. Index Vector of Character Strings
+ If an object has a name attribute, we can take a subset of the vector by calling the names of the elements

--

.pull-left[

+ For example, we can use this to take a subset of the columns of the NYTimes data
```{r}
ct[1:5, c("county", "cases")]
```
]


--

.pull-right[

+ Same as subsetting by column number, but R looks up the column number for you
```{r}
ct[1:5, c(2,5)]
```
]





---
## Using Index Vectors to Sort Data Frames
- We can use `order()` along with subsetting operators to sort a data frame by a specific column. 

--

- Let's subset to June 1st, put it in ascending order of `cases`, and look at the first (lowest) five

--

```{r}
june1_inds <- which(ct$date=="2020-06-01")
sort_inds <- order(ct$cases[june1_inds], decreasing=FALSE)
```
--
```{r}
ct[sort_inds[1:5],]
```
--

**That doesn't look right**.  What went wrong? 





---
## Understanding the problem

Let's first understand how `order()` works.

--

- Consider a vector `x` as below
```{r}
x <- c(4, 2, 1, 3, 5)
```

--

- If you were to place the elements of `x` in ascending order, the 3rd element in `x` would come first, then the 2nd, then the 4th, 1st, and 5th

--

- This is what `order()` gives you:

```{r}
order(x)
```

--

- Note: `order(x)` should have the same length as the vector it evaluates!




---
## Understanding the problem cont'd
Back to our problem: We made `sort_inds` from a **subset** of the data (only June 1st)...

```{r, eval=F}
june1_inds <- which(ct$date=="2020-06-01")
sort_inds <- order(`ct$cases[june1_inds]`, decreasing=FALSE)
```
--

But then applied the order in `sort_inds` to the **non-subsetted** data.
```{r eval=F}
`ct[sort_inds[1:5],]`
```

--

&nbsp;

We can also see the mismatch in lengths:
```{r}
length(sort_inds)
nrow(ct)
```




---
## Fixed:

```{r, eval=F}
june1_inds <- which(ct$date=="2020-06-01")
ct_june1 <- ct[june1_inds, ]  # create new subsetted df
sort_inds <- order(ct_june1$cases)
ct_june1[sort_inds[1:5],]

```

--

```{r, echo=F}
june1_inds <- which(ct$date=="2020-06-01")
ct_june1 <- ct[june1_inds, ]  # create new subsetted df
sort_inds <- order(ct_june1$cases)
ct_june1[sort_inds[1:5],]

```

--

#### &nbsp;

*Brief aside:* Anything concerning here? 

--

(you'll address it in the between-session "homework")



---
## A few other ways to subset

A few other ways of subsetting can be pretty handy!

--

- `subset()`: more readable, but doesn't generate / save an index vector

--
```{r, eval=F}
subset(ct, ct$state=="California" 
           & ct$date=="2020-06-01"
           & ct$cases > 5000)
```

--

&nbsp;

- `dplyr` library: 
  - major advantage: highly readable code
  - less opportunity for error (or, at least, different opportunities!)
  - also (not shown here) easy to perform operations on subgroups
  
--
```{r, eval=F}
library(dplyr)
ct %>% 
  filter(date=="2020-06-01") %>%
  arrange(cases, state, county) %>%
  slice(1:5)
```




---
## Saving data: to load back into R

Before we move on, let's save our data.

To save (multiple) R objects into a file easily imported back into R, use `save()`.  

--

+ (I find it useful to include a vector listing the contents of the file)

--
```{r}
contents <- c("ct", "ct_june1")
save(contents, ct, ct_june1, file="data/session1.Rdata")
```

--

*Note:* If you don't specify the full path in the `file=` argument, make sure you know what your current working directory is first!

--

+ In addition to `getwd()`, `setwd()`, and the RStudio dropdown menus, you can also use the `here` package (not covered, 
--
um, 
--
here...)

--

+ using an R project also mitigates this worry for the most part

--

There is also `save.image()` to save the entire workspace, but it is somewhat frowned upon





---
## Saving data: to load back into R
Then when you want to load this data later, use

```{r, eval=F}
load("data/session1.Rdata")
```

--

You might have forgotten what is in there!  

- If starting from an empty workspace, just look at the Environment pane in RStudio
- If your Environment pane is already full of stuff, that `contents` vector will be quite handy.

--

```{r}
contents
```






---
## Saving data: to share
To save a matrix or dataframe to be shared, `.csv` format is usually preferred.  

```{r, eval=F}
write.table(ct_june1,
            file = "data/ct_june1.csv",
            sep = ",",
            col.names = TRUE,
            row.names = FALSE)
```

--

To load it later, just use
```{r, eval=F}
read.csv("data/ct_june1.csv")
```







---
class: inverse
## Session 1 Topics

1. R and Rstudio basics (credit to Chris Galbraith, Emily Smith)
  + R fundamentals: data types, data structures, reading data, subsetting
  + Using R: functions, loops, writing data

2. Basic data exploration
  + Getting a sense of your data: summaries, tables
  + Making your data useful: transformations
  + plotting with base R





---
class: inverse, animated, fadeIn
## Session 1 Topics

1. R and Rstudio basics (credit to Chris Galbraith, Emily Smith)
  + **R fundamentals: data types, data structures, reading data, subsetting**
  + Using R: functions, loops, writing data

2. **Basic data exploration**
  + **Getting a sense of your data: summaries, tables**
  + **Making your data useful: transformations**
  + **plotting with base R**








---
## Packages

+ R packages are a way to maintain collections of R functions and data sets

+ Packages allow for easy, transparent and cross-platform extension of the R base system




---
## Packages
- Terminology:

  - *Package*: an extension of the R base system with code, data and documentation in a standardized format
  - *Library*: a directory containing installed packages
  - *Repository*: a website providing packages for installation
  - *Source*: the original version of a package with human-readable text and code
  - *Base packages*: part of the R source tree, maintained by R Core

--

- For more info on how R packages are developed, please read [Creating R Packages: A Tutorial](http://cran.r-project.org/doc/contrib/Leisch-CreatingPackages.pdf) by Friedrich Leisch.

- Go to https://cran.r-project.org/web/packages/ for a list of all available packages.


---
## Installing Packages
There are two main ways to install a package in R:

--

1. Installing from CRAN: install a package directly from the repository

  + Using R studio: `Tools > Install Packages...`
  + From R console: `install.packages("name_of_package")`
    
--

2. Installing from source: first download the add-on R package and then type the following in your console:

    + `install.packages("path_to_file", repos = NULL, type = "source")` 

Once you install a package, you need to load it into R using the function `library()`





---
## Installing Packages, contd.

Let's install the package `RColorBrewer`, which provides preset color palettes for use in plotting, and load it (we'll use it later).

```{r eval=FALSE}
install.packages("RColorBrewer")  # put it in quotes!
library(RColorBrewer)  # load it into your R workspace
```






---
## Popular Packages

+ To visualize data:

  + `ggplot2`: to create beautiful graphics
  + `googleVis`: to use Google Chart tools
  + `plotly`: to create interactive graphs

--

+ To report results:
  + `shiny`: to create interactive web-based apps
  + `knitr`: to combine R codes and Latex/Markdown codes
  + `rmarkdown`: to create documents (slides, pdfs, html, et cetera)
  + `slidify`: to build HTML 5 slide shows

--

+ To write high-performance R code:
  + `rcpp`: to write R functions that call C++ code
  + `data.table`: to organize datasets for fast operations
  + `parallel`: to use parallel processing in R

--

Many others; this list changes quickly.





---
## Functions in R

- Consider the function `quantile()`
- Type in `?quantile` to load the help file [(online version here)](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/quantile)

```{r, eval=FALSE}
?quantile
```

--

- Can see that `quantile()` has 5 arguments: 

  - `x`: numeric vector
  - `probs`: the quantiles of interest
  - `na.rm`: ignore `NA` values (logical)
  - `names`: include quantile labels in output vector (logical)
  - `type`: which of 9 quantile algorithms to use (integer 1:9)

- Can also see that quantile() only requires 1 argument (defaults specified)

---
## Function help files


Function help files

1. specify which arguments have default values (and what those values are)

--

  - `quantile(x, probs = seq(0, 1, 0.25), na.rm = FALSE, names = TRUE, type = 7, ...)`
  
--

1. describe the arguments taken by the function

--

1. provide usage examples (scroll down)

--

1. can still be clear as mud  




---
## Where to get help:

Thankfully there is this thing called the "internet."  

--

Google usually turns up one of the following, and in my experience these are usually the most helpful.

- [stackoverflow](https://stackoverflow.com/questions/tagged/r) for R code
- [Cross-Validated](https://stats.stackexchange.com/) for questions about statistics
- [R-bloggers](https://www.r-bloggers.com/how-to-learn-r-2/) for tutorials

--

Especially for help with packages:
- CRAN reference manuals and `browseVignettes()`







---
## Control Structures in R

Before we continue to writing our own functions, we need to cover **control structures** and the `apply()` functions in R.

--

Control structures dictate the sequence in which lines of code are executed.  

--
#### &nbsp;

Most commonly we use `if` statements, and `for` and `while` loops.  




---
## Control Structures: if

```{r if_syntax_do_not_run, eval = F}
if (condition){
  # do something
} else if (condition2) {
  # do something else
} else {
  # do this other catchall thing
}
```

`if` statements branch your code depending on a logical test:

- `condition` must be a vector of length 1

--

```{r}
x <- sample(1:5, size=1)
if (x<3){
  print("less than 3")
} else {
  print("greater than / equal to 3")
}
```





---
## Control Structures: ifelse
```{r ifelse_syntax_do_not_run, eval=F}
ifelse(TF_vector, do_if_true, do_if_false)
```

+ `ifelse` is a **vectorized** version of an if statement
  + `if (TF_vector)` will only look at the first element in `TF_vector` 

--

#### &nbsp;

```{r}
x <- 1:5
ifelse(x<3, "small", "large")
```





---
## Control Structures: while 

```{r while_syntax_do_not_run, eval=FALSE}
while (condition){
  # do this over and over
  `# modify condition!`
}
```


A `while` loop repeats itself until its condition becomes false.  
- make sure you have a way of exiting the loop!

--
```{r}
x <- 1
while (x < 5){
  print(x)
  x <- x+1
}
```




---
## Control Structures: for 

```{r for_syntax_do_not_run, eval=FALSE}
for (el in set){
  #do something depending on el
}
```

A `for` loop does something for each element in a set.

--
#### &nbsp;

```{r}
x <- c("a", "b", "c", "d")
for (let in x){
  print(let)
}
```



---
## Control Structures: for 

For any marginally complex `for` loop, using a set of indices is usually better:

--

For an example, I've randomly sampled 25 letters with replacement and placed them in a 5x5 matrix below.

```{r, echo=FALSE}
letter_mat <- matrix(sample(letters, 25, replace=TRUE),
                     nrow=5)
letter_mat
```

--

Now let's take the elements directly above the diagonal (4 of them):

--

```{r}
y <- rep(NA, 4)  # pre-populate vector y
for (i in 1:4){
    y[i] <- letter_mat[i, i+1]
}
print(y)
```





---
## apply() family
Learning to use the `apply()` family is essential for heavy R users.  

--

- The basic idea behind these functions is applying a function recursively on subsets of an object.

  - As you can guess, it can often replace a `for` loop.  

--

- It's important to discuss here because most (if not all) parallel computing packages in R also require understanding how to use `lapply()` 

--

#### &nbsp;

We'll cover `apply()` and `lapply()` today.  But many others exist!  
  - `sapply()`, `mapply()`, `tapply()`, `rapply()`, and just `by`





---
## apply()

```{r apply_syntax_donoteval, eval=F}
apply(mat, MARGIN, function(x) some_func(x, other_args))
```

Use `apply()` to apply a function across a dimension of a matrix, array, or dataframe. 

#### &nbsp;

Think of `apply()` as doing the following (assume `mat` is a 2D matrix):

--

1. breaks `mat` into **component vectors** along the specified `MARGIN`

  - `MARGIN=1` specifies rows, `MARGIN=2` specifies columns, and so on
  
  - e.g. if `MARGIN==1`, `mat` is a collection of row vectors

--

1. performs the specified function `some_func` using each **component vector** 
  - the role of each component (e.g. row) in the function is specified by the role of `x` in `some_func(x, other_args)`.





---
## apply() example

Generate a matrix to apply the `mean()` function to:
```{r}
mat <- rbind(rnorm(10), rnorm(10, 5), rnorm(10, -5, 2))
dimnames(mat) <- list(paste0("row", 1:3), 
                      paste0("col", 1:10))
round(mat,1) # for display on slide
```

--

We will set `MARGIN=1,` which indicates rows.  So the function will be applied to each row vector in `mat`





---
class: animated, fadeIn
## apply() example cont'd

Generate a matrix to apply the `mean()` function to:
```{r, eval=FALSE}
mat <- rbind(rnorm(10), rnorm(10, 5), rnorm(10, -5, 2))
dimnames(mat) <- list(paste0("row", 1:3), 
                      paste0("col", 1:10))
round(mat,1) # for display on slide
```

#### &nbsp;

Since `mean()` only requires 1 argument, we can simplify our `apply()` statement:

--
```{r, eval=F}
apply(mat, 1, mean)
```
--
```{r, echo=F}
apply(mat, 1, mean)
```





---
## apply() example 2

Let's see the syntax when we want to specify other arguments:

Here is similar data (the only difference is 1000 columns instead of 10)

```{r, results='hide'}
mat <- rbind(rnorm(1000), rnorm(1000, 5), rnorm(1000, -5, 2))
dimnames(mat) <- list(paste0("row", 1:3), 
                      paste0("col", 1:1000))
```

We'll apply the `quantile()` function, but we'll specify that we want the 0.025, 0.5, and 0.975 quantiles.


--
```{r, eval=F}
apply(mat, 1, function(x) quantile(x, probs=c(.025, .5, .975)))
```
--
```{r, echo=F}
apply(mat, 1, function(x) quantile(x, probs=c(.025, .5, .975)))
```

--

You can also **write your own functions** and pass them into `apply()`.  
--
Which is awesome.





---
## lapply()
`lapply()` applies a function to each element in a list.  

--

Example given as an exercise!






---
## Writing your own functions:
OK, so you need to do something specific to your use case, and you will need to do it more than once.  

--

You should write a **function** for it.

--

First and, if it is going to be complex, the most important step: 
--
**Google to see if it already exists.**

--

Second step: 
--
Think of other ways to describe what you need to do, and **Google to see if it already exists.**




---
## Why not just copy and paste?

Copy-pasting multiple lines of code is a hassle in many ways (variable name management, messy code, etc.)

--

Functions have a few other advantages:

--

1. They do not pollute or interact with your workspace

--

1. More concise, easier-to-understand code

--

1. Realize you made a mistake in this thing you do over and over again?  Just change your **function** and re-run everything.



---
## Function syntax

```{r}
my_func <- function(arg1, arg2=1:4){  # declare function my_func
  result <- sum(arg1) / sum(arg2)     # do stuff
  return(result)                      # output
}
```

A function in R performs a set of operations using arguments. 

--

- variables defined within a function are local 

  - e.g. `result` exists only while `my_func` is executed

--

```{r}
my_func(arg1=1:100)
```

--
```{r, error=TRUE}
result # does not exist outside of function
```

--
```{r, error=TRUE}
arg1   # does not exist outside of function
```




---
class: animated, fadeIn
## Function syntax

```{r}
my_func <- function(arg1, arg2=1:4){  # declare function my_func
  result <- sum(arg1) / sum(arg2)     # do stuff
  return(result) 
}
```

A `function` in R performs a set of operations using arguments. 

--

- Your function must specify its output (can output *only one object*) either by:

  1. having the last line be an operation *without* variable assignment (e.g. just `sum(arg1) / sum(arg2)`)
  
  1. using `return()`.  Can only return 1 object, but the object can be a vector, list, etc.



---
class: animated, fadeIn
## Function syntax

```{r}
my_func <- function(arg1, arg2=1:4){  # declare function my_func
  result <- sum(arg1) / sum(arg2)     # do stuff
  return(result) 
}
```

A `function` in R performs a set of operations using arguments. 

--

- your function will perform the same operation (on different arguments) each time you call it:

```{r}
my_func(arg1=1:100)
my_func(arg1=1)
my_func(arg1=100:200, arg2=5:15)
```






---
## Writing your own functions:

In general, for more complex functions, I recommend writing the non-function version first (easier to debug).

Let's try writing a function that we will be able to `apply()` to the dataset later (we'll do it by county).  

--

Specifically, we'll make a function that
1. detects if all consecutive days in a range are present, and 
1. if not, counts the number of time skips and total days missing.





---
## Writing your own functions: example
We'll be using the `date` column to check consecutive days.  

We could work on it as a factor, but base R includes a `Date` class which will make things a bit clearer and easier.

```{r}
ct$date <- as.Date(ct$date)
```

--

And since we're planning to apply this by county, let's work on one sample county:

```{r}
dat <- subset(ct, fips==6059)
dat[1:3,]
```





---
## Writing your own functions: example (2)
Now we can use the `diff()` function, which calculates the difference between consecutive elements in a vector. For example:

```{r}
diff(c(0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55))
```

--

Let's try it on our dates:
```{r, eval=F}
diff(dat$date)
```

--

```{r, echo=F}
diff(dat$date)
```


Cool!  Turns out `diff()` has a specific operation for objects of class `Date`.  
--
... But our subset is a little boring in this regard.






---
## Writing your own functions: example (3)

  Let's make it a bit more interesting:

```{r}
dat <- dat[c(1:5, 10:15, 20:25), ]
```

--

So there should be 2 jumps in date, with a total of 8 days missing.

--

Let's try `diff()` again:
```{r}
diff(dat$date)

```





---
## Writing your own functions: example (4)
Now we'll write code to see if every date is included by counting how many jumps there are and how many days are missing.

```{r}
daydiffs <- diff(dat$date)
daydiffs
```
--
```{r}
n_jumps <- sum(daydiffs != 1)
n_jumps
```
--
```{r}
total_missed <- sum(daydiffs-1) 
total_missed
```

Looks like it works!





---
## Writing your own functions: example (5) 
Final step: wrap it into a function
- notice the only input was `dat$date`, a vector of class `Date`

--

```{r}
days_missed <- function(date_vec){
  daydiffs <- diff(date_vec) #changed dat$date to date_vec
  n_jumps <- sum(daydiffs != 1)
  total_missed <- sum(daydiffs-1)
  
  # format the output
  res <- c(n_jumps, total_missed)
  names(res) <- c("jumps", "total")
  
  return(res)
}
```

--

```{r}
days_missed(dat$date)
```








---
## A few general resources:

- [stackoverflow](https://stackoverflow.com/questions/tagged/r) for R code
- [Cross-Validated](https://stats.stackexchange.com/) for questions about statistics
- [R-bloggers](https://www.r-bloggers.com/how-to-learn-r-2/) for tutorials


Especially for help with packages:
- CRAN reference manuals and `browseVignettes()`


In addition, anything by Hadley Wickham:
  - [R for data science](https://r4ds.had.co.nz/)
  - [Advanced R](http://adv-r.had.co.nz/)
  - [ggplot2: Elegant Graphics for Data Analysis](https://ggplot2-book.org/)



---
## End of Session 1 Part 1
